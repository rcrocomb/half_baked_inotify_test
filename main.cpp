/**
    Author: Robert Crocombe
    Classification: Unclassified
    Initial Release Date:

*/

#include <signal.h>                                 // POSIX signal handling
#include <unistd.h>                                 // getopt, read
#include <string.h>
#include <stdint.h>                                 // uint8_t

#include <sys/inotify.h>
#include <limits.h>                                 // SSIZE_MAX

#include <sys/time.h>                               // gettimeofday

#include <vector>
#include <string>
#include <cstdlib>

#include "program_IO.h"

////////////////////////////////////////////////////////////////////////////////
// Globals and Macros
////////////////////////////////////////////////////////////////////////////////

// to turn async signal into synchronous request to stop
static volatile sig_atomic_t stop;

namespace
{
    enum
    {
        DEFAULT_A_VALUE = 0,
        INOTIFY_BUFFER_SIZE = 1024
    };
}

struct commandline_options
{
    int an_option;
    std::vector<std::string> filenames;

    commandline_options(int option_a = DEFAULT_A_VALUE):
        an_option(option_a),
        filenames()
    {

    }
};

namespace main_name
{
    const std::string NAME("main");
}

#define NAME main_name::NAME
#define ALWAYS(fmt, args...)  ALWAYS_WITH_NAME(NAME, fmt, ##args)
#define CPRINT(fmt, args...)  CPRINT_WITH_NAME(NAME, fmt, ##args)
#define VPRINT(fmt, args...)  VPRINT_WITH_NAME(NAME, fmt, ##args)
#define WARNING(fmt, args...) WARNING_WITH_NAME(NAME, fmt, ##args)
#define ERROR(fmt, args...) ERROR_WITH_NAME(NAME, fmt, ##args)
#define RUNTIME(fmt, args...) RUNTIME_WITH_NAME(NAME, fmt, ##args)
#define REPORT(fmt, args...) REPORT_WITH_NAME(NAME, fmt, ##args)

////////////////////////////////////////////////////////////////////////////////
// Prototypes
////////////////////////////////////////////////////////////////////////////////

void signal_handler(int signum, siginfo_t *info, void *p);
const char * signum_to_string(int signum);

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

/**

*/

void
signal_handler(int signum, siginfo_t *info, void *p)
{
    cprint("Caught signal %d: %s -- ",
               signum, signum_to_string(signum));

    if (!info)
    {
        cprint("NULL siginfo_t pointer!\n");
        if ((signum == SIGSEGV) || (signum == SIGBUS))
        {
            cprint("Attempting dirty shutdown *NOW*\n");
            kill(0, SIGINT);
            exit(0);
        }

        cprint("Attempting synchronous termination\n");
        stop = 1;
        return;
    }

    else if (info->si_errno != 0)
        cprint("si_errno is non-zero: %d\n", info->si_errno);
    else
        cprint("no error detected\n");

    switch(info->si_code)
    {
    case SI_QUEUE:  // sent via sigqueue()
        cprint("Sigqueue: pid is %d from user %d: value is %d\n",
                   info->si_pid, info->si_uid,
                   info->si_value.sival_int);
        break;

    case SI_USER:   // sent via kill() or sigsend()
        cprint("Signal sent from pid %d and user %d\n",
               info->si_pid, info->si_uid);
        // FALL THROUGH!
    default:        // not generated by user -- but reason is encoded
        switch(signum)
        {
        case SIGINT:
            cprint("SIGINT received: synchronous shutdown.\n");
            stop = 1;
            break;

        case SIGSEGV:
            cprint("SIGSEGV: segfault @ %12llx", (unsigned long long)info->si_addr);
            switch(info->si_code)
            {
            case SEGV_MAPERR:
                cprint(": address not mapped to object.\n");
                break;
            case SEGV_ACCERR:
                cprint(": invalid permissions for mapped object.\n");
                break;
            default:
                /* Regular generic segfault */
                cprint("\n");
            }

            cprint("Attempting dirty shutdown *NOW*\n");
            // send SIGINT signal to all processes in the process group.
            kill(0, SIGINT);
            exit(0);

            break;

        case SIGBUS:
            // cannot return from signal handler with SIGBUS, because the
            // processor's PC is pointing to the instruction where the fault
            // occurs, so it'd simply fault again.  So exit() and hope for
            // the best.
            cprint("SIGBUS: memory fault @ %016llx\n", (unsigned long long)info->si_addr);
            cprint("Attempting dirty shutdown *NOW*\n");
            // send SIGINT signal to all processes in the process group.
            kill(0, SIGINT);
            exit(0);

        case SIGUSR1:
            cprint("SIGUSR1: what?\n");
            break;

        case SIGUSR2:
            cprint("SIGUSR2: what?\n");
            break;

        case SIGCHLD:
            cprint("SIGCHLD: pid is %d, status is %d: ",
                   info->si_pid, info->si_status);
            switch(info->si_code)       // yes, switch on si_code again
            {
            case(CLD_EXITED):
                cprint("Child exited.\n");
                break;

            case(CLD_KILLED):
                cprint("Child killed.\n");
                break;

            case(CLD_DUMPED):
                cprint("Child terminated abnormally (and dumped core)).\n");
                stop = 1;
                break;

            case(CLD_TRAPPED): cprint("Child trapped while tracing.\n"); break;
            case(CLD_STOPPED): cprint("Child stopped.\n"); break;
            case(CLD_CONTINUED): cprint("Child is continuing.\n"); break;
            default:
                cprint("Yow: unknown child status of %d\n", info->si_code);
            }

            if (!stop)
            {
                warning("SIGCHLD when not terminating: boned?\n");
                cprint("Attempting dirty shutdown *NOW*\n");
                // send SIGINT signal to all processes in the process group.
                kill(0, SIGINT);
                exit(0);
            }

            break;
        default:
            cprint("Caught unhandled signal?\n");
        }
    }
}

const char *
signum_to_string(int signum)
{
    #define SIGNAME(a) case (a): return #a
    switch(signum)
    {
    SIGNAME(SIGHUP); SIGNAME(SIGINT); SIGNAME(SIGQUIT); SIGNAME(SIGILL);
    SIGNAME(SIGTRAP); SIGNAME(SIGABRT); SIGNAME(SIGFPE); SIGNAME(SIGKILL);
    SIGNAME(SIGBUS); SIGNAME(SIGSEGV); SIGNAME(SIGSYS); SIGNAME(SIGPIPE);
    SIGNAME(SIGALRM); SIGNAME(SIGTERM); SIGNAME(SIGUSR1); SIGNAME(SIGUSR2);
    SIGNAME(SIGCHLD); SIGNAME(SIGPWR); SIGNAME(SIGWINCH); SIGNAME(SIGURG);
    SIGNAME(SIGPOLL); SIGNAME(SIGSTOP); SIGNAME(SIGTSTP); SIGNAME(SIGCONT);
    SIGNAME(SIGTTIN); SIGNAME(SIGTTOU); SIGNAME(SIGVTALRM);
    SIGNAME(SIGPROF); SIGNAME(SIGXCPU); SIGNAME(SIGXFSZ);
    default: return "Unknown signal number!";
    }
    #undef SIGNAME
}

void
usage(void)
{
    ALWAYS("Don't");
}

long
arg_as_long(char *optarg, const std::string &option_string)
{
    char *endptr = 0;
    errno = 0;
    long value = std::strtol(optarg, &endptr, 0);
    if (errno)
        ERROR("Converting %s for '%s'", C(option_string), optarg);

    return value;
}

double
arg_as_double(char *optarg, const std::string &option_string)
{
    char *endptr = 0;
    errno = 0;
    double value = std::strtod(optarg, &endptr);
    if ((value == 0.0) && (endptr == optarg))
        RUNTIME("Unable to convert %s '%s' to float", C(option_string),
optarg);
    else if ((value == 0.0) && (errno == ERANGE))
        RUNTIME("Floating point %s underflows: '%s'", C(option_string),
optarg);

    return value;
}

void
get_commandline_options(int argc, char *argv[], commandline_options *options)
{
    using ::optarg;
    using ::opterr;

    int c;
    extern char *optarg;
    extern int opterr;
    opterr = 1;

    if (!options)
        RUNTIME("Null commandline options data struture");

    while ((c = getopt(argc, argv, "")) != -1)
    {
        switch (c)
        {
        case '?':
        default:
            usage();
            RUNTIME("Invalid commandline option");
        }
    }

    for ( ; !stop && (optind < argc); ++optind)
    {
        CPRINT("Adding filename '%s'\n", argv[optind]);
        options->filenames.push_back(argv[optind]);
    }

    if (options->filenames.size() == 0)
        RUNTIME("Must have a filename to proceed.\n");
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////

double
now(void)
{
    timeval tv;
    int ret = gettimeofday(&tv, NULL);
    if (ret == -1)
        ERROR("gettimeofday");
    return tv.tv_sec + (1E-6 * tv.tv_usec);
}

bool
print_inotify_event(const inotify_event &event)
{
    CPRINT("wd:     %d (%#08x)\n", event.wd, event.wd);
    CPRINT("mask:   %08x\n", event.mask);
    uint32_t mask_copy = event.mask;
    for (unsigned i = 0; mask_copy; ++i)
    {
        bool is_set = mask_copy & 0x1;
        mask_copy = mask_copy >> 1;
        if (is_set)
        {
            #define PRINT_IT(a) case (a): CPRINT("\t%s\n", #a); break
            switch ((1 << i))
            {
            PRINT_IT(IN_ACCESS);
            PRINT_IT(IN_MODIFY);
            PRINT_IT(IN_ATTRIB);
            PRINT_IT(IN_CLOSE_WRITE);
            PRINT_IT(IN_CLOSE_NOWRITE);
            PRINT_IT(IN_OPEN);
            PRINT_IT(IN_MOVED_FROM);
            PRINT_IT(IN_MOVED_TO);
            PRINT_IT(IN_CREATE);
            PRINT_IT(IN_DELETE);
            PRINT_IT(IN_DELETE_SELF);
            PRINT_IT(IN_MOVE_SELF);
            PRINT_IT(IN_UNMOUNT);
            PRINT_IT(IN_Q_OVERFLOW);
            PRINT_IT(IN_IGNORED);
            PRINT_IT(IN_ONLYDIR);
            PRINT_IT(IN_DONT_FOLLOW);
            PRINT_IT(IN_MASK_ADD);
            PRINT_IT(IN_ISDIR);
            PRINT_IT(IN_ONESHOT);
            default:
                CPRINT("Unknown mask value at bit %d\n", i);
            }
            #undef PRINT_IT
        }
    }
    CPRINT("cookie: %08x\n", event.cookie);
    CPRINT("len:    %u\n", (unsigned int)event.len);
    if (event.len > 0)
    {
        CPRINT("name: '%s' length %lu\n", event.name, (unsigned long)strlen(event.name));
    } else
    {
        CPRINT("name: --NONE--\n");
    }
    CPRINT("%s\n", "----------------------------------------------------------------------");

    return event.mask & IN_Q_OVERFLOW;
}

void
do_stuff(void)
{
    int inotify_fd = inotify_init();
    if (inotify_fd == -1)
        ERROR("inotify_init()");
    CPRINT("inotify_init... OK\n");

    try {
        int wd = inotify_add_watch(inotify_fd, ".", IN_ALL_EVENTS);
        if (wd == -1)
            ERROR("inotify_add_watch");
        CPRINT("inotify_add_watch for '.' as %d (%#08x) ... OK\n", wd, wd);

        try {
            // fits some 'struct inotify_event' and a path?
            uint8_t buffer[INOTIFY_BUFFER_SIZE];

            while (!stop)
            {
                CPRINT("%.3f Reading...\n", now());
                ssize_t bytes_read = read(inotify_fd, buffer, sizeof(buffer));
                CPRINT("Got %ld bytes\n", (long)bytes_read);
                if (bytes_read < 0)
                {
                    CPRINT("Negative bytes read... quittin' time?\n");
                    continue;
                }

                if (!bytes_read)
                    continue;

                if (bytes_read > SSIZE_MAX)
                    RUNTIME("Woh... bytes (%ld) > SSIZE_MAX (%ld): I give up",
                            (long)bytes_read, (long)SSIZE_MAX);

                // we've eliminated negative
                if ((size_t)bytes_read < sizeof(struct inotify_event))
                {
                    RUNTIME("Too few bytes to be an inotify_struct: %ld vs. %ld",
                            (long)bytes_read,
                            (long)(sizeof (struct inotify_event)));
                }

                uint8_t *buffer_end = buffer + bytes_read;
                uint8_t *buffer_current = buffer;
                while (buffer_current < buffer_end)
                {
                    inotify_event * const event = (inotify_event *)buffer_current;
                    bool overflowed = print_inotify_event(*event);
                    if (overflowed)
                    {
                        ALWAYS("Overflowed event queue: moving on\n");
                        break;
                    }

                    // event->len seems to not really be exactly the string length, so maybe we don't
                    // need to add '+ 1'?
                    buffer_current = (uint8_t *)(event->name + event->len);
                }
            }

        } catch (...)
        {
            if (inotify_rm_watch(inotify_fd, wd) != 0)
                REPORT("inotify_rm_watch failed");
            else
                CPRINT("inotify_rm_watch() succeeded\n");
            throw;
        }

        if (inotify_rm_watch(inotify_fd, wd) != 0)
            ERROR("inotify_rm_watch failed");
        else
            CPRINT("inotify_rm_watch() succeeded\n");
    } catch (...)
    {
        if (close(inotify_fd) != 0)
            REPORT("close() failed for the inotify_fd");
        else
            CPRINT("close() succeeded for the inotify_fd\n");
        throw;
    }

    if (close(inotify_fd) != 0)
        REPORT("close() failed for the inotify_fd");
    else
    {
        CPRINT("close() succeeded for the inotify_fd\n");
        CPRINT("Everything closed down okay\n");
    }
}

int
main(int argc, char *argv[])
{
    struct sigaction action;
    int error = 0;

    std::cout.sync_with_stdio();

    // Setup signal handling
    action.sa_sigaction = signal_handler;
    action.sa_flags = SA_SIGINFO;
    error += sigaction(SIGINT, &action, 0);
    error += sigaction(SIGSEGV, &action, 0);
    if (error)
    {
        REPORT("Error in sigaction");
        return 0;
    } else
        CPRINT("Signal handler installed.\n");

    try
    {
        do_stuff();
    } catch (std::exception &e)
    {
        ALWAYS("Caught exception.\n");
    } catch (...)
    {
        ALWAYS("Caught non-exception.\n");
    }

    return 0;
}

#undef NAME
#undef ALWAYS
#undef CPRINT
#undef VPRINT
#undef WARNING
#undef ERROR
#undef RUNTIME
#undef REPORT

